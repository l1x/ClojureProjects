#+TITLE: Reversible Arithmetic on Collections
#+AUTHOR: The Team of Fu
#+LATEX_HEADER: \usepackage{savesym}
#+LATEX_HEADER: \savesymbol{iint}
#+LATEX_HEADER: \savesymbol{iiint}
#+LATEX_HEADER: \usepackage{amsmath}

#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{tikz-cd}
#+LATEX_HEADER: \usetikzlibrary{matrix,arrows,positioning,scopes,chains}
#+LATEX_HEADER: \tikzset{node distance=2cm, auto}
#+LATEX_HEADER: \usepackage{framed}
#+LATEX_HEADER: \usepackage[framed]{ntheorem}
#+LATEX_HEADER: \newframedtheorem{myrule}{Rule}[section]
#+LATEX_HEADER: \newframedtheorem{mydefinition}{Definition}[section]
#+BEGIN_COMMENT
The following line generates a benign error
#+LATEX_HEADER: \usepackage{amsmath, amsthm, amssymb}
#+END_COMMENT
#+STYLE: <link rel="stylesheet" type="text/css" href="styles/default.css" />
#+BEGIN_COMMENT
  TODO: Integrate BibTeX
#+END_COMMENT

+ Remark :: This is a literate program.
              [fn:LP: http://en.wikipedia.org/wiki/Literate_programming.]
              Source code /and/ PDF documentation spring
              from the same, plain-text source files.

* Introduction

  We often encounter data records or rows as hash-maps, lists, vectors
  (also called /arrays/). In our financial calculations, we often want
  to add up a collection of such things, where adding two rows means
  adding the corresponding elements and creating a new virtual row from
  the result. We also want to /un-add/ so we can undo a mistake, roll
  back a provisional result, perform a backfill or allocation: in short,
  get back the original inputs. This paper presents a library supporting
  reversible on a large class of collections in
  Clojure.[fn::http://clojure.org]

* Mathematical Background

  Think of computer lists and vectors as /mathematical vectors/ familiar
  from linear algebra:[fn::http://en.wikipedia.org/wiki/Linear_algebra]
  ordered sequences of numerical /components/ or /elements/. Think of
  hash-maps, which are equivalent to /objects/ in object-oriented
  programming,[fn::http://en.wikipedia.org/wiki/Object-oriented_programming]
  as sparse vectors[fn::http://en.wikipedia.org/wiki/Sparse_vector] of
  /named/ elements.

  Mathematically, arithmetic on vectors is straightforward: to add
  them, just add the corresponding elements, first-with-first,
  second-with-second, and so on.  Here's an example in two dimensions:
  $$[1, 2] + [3, 4] = [4, 6]$$

  Clojure's /map/ function does mathematical vector addition straight
  out of the box on Clojure vectors and lists.  (We don't need to write
  the commas, but we can if we want -- they're just whitespace in
  Clojure):
#+BEGIN_SRC clojure :tangle no
(map + [1 2] [3 4])
#+END_SRC

#+RESULTS:
| 4 | 6 |

\begin{verbatim}
==> [4 6]
\end{verbatim}

  With Clojure hash-maps, add corresponding elements via /merge-with/:
#+BEGIN_SRC clojure :tangle no
(merge-with + {:x 1, :y 2} {:x 3, :y 4})
#+END_SRC

#+RESULTS:
| :y | 6 | :x | 4 |

\begin{verbatim}
==> {:x 4, :y 6}
\end{verbatim}

  The same idea works in any number of dimensions and with any kind of
  elements that can be added (any /mathematical
  field/:[fn::http://en.wikipedia.org/wiki/Field_(mathematics)]
  integers, complex numbers, quaternions -- many more.

  Now, suppose you want to /un-add/ the result, \verb|[4 6]|? There is
  no unique answer.  All the following are mathematically correct:
\begin{align*}
[-1, 2] + [5, 4] &= [4, 6] \\
[ 0, 2] + [4, 4] &= [4, 6] \\
[ 1, 2] + [3, 4] &= [4, 6] \\
[ 2, 2] + [2, 4] &= [4, 6] \\
[ 3, 2] + [1, 4] &= [4, 6] \\
\end{align*}
  and a large infinity of more answers.

* A Protocol for Reversible Arithmetic

  Let's define a protocol for /reversible arithmetic in vector spaces/
  that captures the desired functionality.  We want a /protocol/ --
  Clojure's word for
  /interface/,[fn::http://en.wikipedia.org/wiki/Interface_(computing)]
  because we want several implementations with the same reversible
  arithmetic: one implementation for vectors and lists, another
  implementation for hash-maps.  /Protocols/ let us ignore inessential
  differences: the protocol for reversible arithmetic on is the same for
  all compatible collection
  types.[fn::including streams over time! Don't forget Rx and SRS.]

  Name our objects of interest /algebraic vectors/ to distinguish them
  from Clojure's existing /vector/ type. Borrowing an idiom from C\# and
  .NET, name our protocol with an initial /I/ and with camelback
  casing.[fn::http://en.wikipedia.org/wiki/CamelCase] Don't misread
  /IReversibleAlgebraicVector/ as ``irreversible algebraic vector;''
  rather read it as ``I Reversible Algebraic Vector'', i.e., ``Interface
  to Reversible Algebraic Vector,'' where the ``I'' abbreviates
  ``Interface.''

  We want to add, subtract, and scale our reversible vectors, just as we
  can do with mathematical vectors.  /Add/ should be multiary, because
  that's intuitive. /Sub/ should be binary, because multiary sub is
  ambiguous. Include inner product, since it is likely to be useful.
  Though we don't have immediate scenarios for subtraction, scaling, and
  inner product, the mathematics tells us they're fundamental. Putting
  them in our design /now/ affords two benefits:
  1. when the need arises, we won't have to change the code
  1. their existence in the library may inspire usage scenarios



+ Remark :: The choice to include operations in a library in the absense
            of scenarios is a philosophical
            choice,[fn::http://en.wikipedia.org/wiki/Design_philosophy]
            perhaps more akin to /Action-Centric/ design or /proactive/
            design as opposed to /Hyper-Rationalist/ or /minimalist/
            design. The former philosophy promotes early inclusion of
            facilities likely to be useful or inspirational, whereas the
            latter philosophy demands ruthless rejection of facilities
            not known to be needed. Both buy into to removing facilities
            /known to be not needed/, of course. The former philosophy
            relies on intuition, taste, judgment, and experience; and
            the latter philosophy embraces ignorance of the future as a
            design principle. We thus prefer the former.



  Finally, we need /undo/ and /redo/, the differentiating features of
  reversible algebraic vectors. Here is our protocol design:

#+NAME: reversible-algebraic-vector-protocol
#+BEGIN_SRC clojure :tangle no
(defprotocol IReversibleAlgebraicVector
  ;; binary operators
  (add   [a b & more])
  (sub   [a b])
  (inner [a b])
  ;; unary operators
  (scale [a scalar])
  ;; reverse any operation
  (undo [a])
  (redo [a])
)
#+END_SRC

* Implementing the Protocol

** Defining r-vectors and a-vectors

   What things represent algebraic vectors?  Things we can operate on
   with /map/ or /merge-with/ to perform basic vector-space operations.
   Therefore, they must be Clojure vectors, lists, or hash-maps.

   The higher-level case wraps reversing information in a hash-map along
   with base-case algebraic vector data. The base data will belong to
   the /\mbox{:a-vector}/ key, by convention.


\begin{mydefinition}[Reversible Algebraic Vector (r-vector)]
   A \textbf{reversible algebraic vector} or \textbf{r-vector} is either
   an algebraic vector, i.e., \textbf{a-vector}, or a hash-map containing
   an \texttt{:a-vector} attribute. An a-vector is either a Clojure
   vector, list, or hash-map that does not contain a \mbox{\texttt{:a-vector}}
   attribute. If an r-vector does contain a \texttt{:a-vector}
   attribute, the value of that attribute must be an a-vector.
\end{mydefinition}

** Checking the Definition

   Here is a type-checking function for a-vector data that promotes
   fluent style. It either returns its input -- like the /identity/
   function -- or throws an exception if something is wrong.

#+NAME: check-a-vector
#+BEGIN_SRC clojure :tangle no
(defn- check-a-vector [that]
  (if (or (list? that)
          (vector? that)
          (and (map? that) (not (contains? that :a-vector))))
      that ; ok -- otherwise:
      (throw (IllegalArgumentException.
        (str "This type of object can't hold vector data: "
             (type that))))))
#+END_SRC

** Fetching a-vector Data

   We need a way to get a-vector data out of any r-vector. If the
   r-vector is an a-vector, just return it. Otherwise, if the r-vector
   is a hash-map, fetch and check the value of the \mbox{:a-vector}
   attribute. In all other cases, reject the input.

   If the input is a hash-map, we must explicitly check for existence of
   key /\mbox{:a-vector}/ so that we can tell the difference between a
   hash-map that has an /\mbox{:a-vector}/ whose value is /nil/, an
   illegal case, and a hash-map that has no /\mbox{:a-vector}/, a legal
   case. We cannot simply apply the keyword /\mbox{:a-vector}/ to the
   candidate r-vector because that application would produce /nil/ in
   both cases. Instead, we apply /\mbox{:a-vector}/ to the candidate
   after checking for existence of the key, and then apply
   /check-a-vector/, defined above.

#+NAME: get-a-vector-helper
#+BEGIN_SRC clojure :tangle no
(defmulti  get-a-vector type)
(defmethod get-a-vector (type [])   [that] that)
;; empty list has its own type, but it is still a list
(defmethod get-a-vector (type '())  [that] that)
(defmethod get-a-vector (type '(0)) [that] that)
(defmethod get-a-vector (type {})   [that]
  (if (contains? that :a-vector)
    ;; throw if the contained a-vector is illegal
    (check-a-vector (:a-vector that))
    ;; otherwise, just return the input
    that))
(defmethod get-a-vector :default    [that]
  (throw (IllegalArgumentException.
    (str "get-a-vector doesn't like this food: " that))))
#+END_SRC

** Unit-Testing get-a-vector

   We require /IllegalArgumentExceptions/ for inputs that are not
   vectors, lists, or hash-maps and for a-vectors that contain
   r-vectors: our design does not nest r-vectors.

#+NAME: bad-ish-test-set
#+BEGIN_SRC clojure :results silent :tangle no
(def ^:private bad-ish-test-set
  '(42 'a :a "a" \a #inst "2012Z" #{} nil true false
   {:a-vector 42  }   {:a-vector 'a  } {:a-vector :a }
   {:a-vector "a" }   {:a-vector \a  } {:a-vector #inst "2012Z"}
   {:a-vector #{} }   {:a-vector nil } {:a-vector true }
   {:a-vector false } {:a-vector {:a-vector 'foo} }
  ))

(def ^:private good-ish-test-set
  '([] () {} [0] (0) {:a 0} [1 0] (1 0) {:a 0, :b 1})  )
#+END_SRC

#+name: get-a-vector-helper-test
#+BEGIN_SRC clojure :results silent :tangle no
(defmacro ^:private exception-to-name [expr]
  `(try ~expr (catch Exception e# (re-find #"[^:]+" (str e#)))))

(defmacro ^:private value-set [fun exprs]
  `(into #{} (map (fn [x#] (exception-to-name (~fun x#)))
                  ~exprs)))

(deftest get-a-vector-helper-test
  (testing "get-a-vector-helper"
    ;; Negative tests
    (is (= #{"java.lang.IllegalArgumentException"}
           (value-set get-a-vector bad-ish-test-set)))
    (is (= (set good-ish-test-set)
           (value-set get-a-vector good-ish-test-set)))
    ;; Positive tests
    (are [x y] (= x y)
        [42] (get-a-vector {:a 1 :a-vector [42]})
       '(42) (get-a-vector {:a 1 :a-vector '(42)})
     {:a 42} (get-a-vector {:a 1 :a-vector {:a 42}})

          [] (get-a-vector {:a 1 :a-vector []})
         '() (get-a-vector {:a 1 :a-vector '()})
          {} (get-a-vector {:a 1 :a-vector {}})
    )
))

#+END_SRC

# \begin{figure}
#   \centering
#   \includegraphics[width=0.5\textwidth]{/Users/rebcabin/tmp/BB_00000.PDF}
#   \caption{\label{fig:fufortune}This means ``Fortune'' and is pronounced ``Fu''.}
# \end{figure}

   To implement the protocol, we need multimethods that dispatch on the
   types of the a-vectors.

#+NAME: one-type
#+BEGIN_SRC clojure :tangle no :results silent
(defn one-type [a]
        (cond
         (or (vector? a) (list? a)) 'seq-ish
         (map? a)                   'map-ish
         :default (throw (IllegalArgumentException.
                          (str ": " a)))))
#+END_SRC

#+NAME: one-type-test
#+BEGIN_SRC clojure :tangle no
(deftest one-type-test
  (testing "type-merging"
    (are [val] (thrown? IllegalArgumentException val)
         (one-type 42)
         (one-type 'a)
         (one-type :a)
         (one-type "a")
         (one-type \a)
         (one-type #inst "2012Z")
         (one-type #{})
         (one-type nil))
    (are [x y] (= x y)
         'seq-ish (one-type  [])
         'seq-ish (one-type '())
         'map-ish (one-type  {})

         'seq-ish (one-type  [0])
         'seq-ish (one-type '(0))
         'map-ish (one-type  {:a 0})

         'seq-ish (one-type  [1 0])
         'seq-ish (one-type '(1 0))
         'map-ish (one-type {:b 1 :a 0})

         'map-ish (one-type {:a 1 :a-vector [42]})
         'map-ish (one-type {:a 1 :a-vector '(42)})
         'map-ish (one-type {:a 1 :a-vector {:a 42}})
         'map-ish (one-type {:a 1 :a-vector []})
         'map-ish (one-type {:a 1 :a-vector '()})
         'map-ish (one-type {:a 1 :a-vector {}})
        )    ))
#+END_SRC

#+NAME: add-data
#+BEGIN_SRC clojure :tangle no
(defn two-types [a b])
(defmulti  add-data two-types)
(defmethod add-data (type [])   [that] that)
(defmethod add-data (type '())  [that] that)
(defmethod add-data (type '(0)) [that] that)
(defmethod add-data (type {})   [that]
  (if (contains? that :a-vector)
    (check-a-vector (:a-vector that))
    that))
(defmethod add-data :default    [that]
  (throw (IllegalArgumentException.
    (str "get-a-vector doesn't like this food: " that))))
#+END_SRC


#+NAME: reversible-algebraic-vector-on-vector
#+BEGIN_SRC clojure :tangle no
(defrecord ReversibleVector [a-vector]
  IReversibleAlgebraicVector
  (add   [a b & more]
         {:priors a, :right-prior b,
                :operation 'add, :a-vector (map + (get-a-vector a)
                                              (get-a-vector b))})
  (sub   [a b] nil)
  (inner [a b] nil)
  (scale [a scalar] nil)
  (undo  [a] nil)
  (redo  [b] nil))
#+END_SRC

#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/README.md :exports none
# ex1
A Clojure library for reversible arithmetic on collections.
## Usage
TODO
## License
Copyright Â© 2013 TODO
#+END_SRC
#+BEGIN_SRC clojure :noweb yes :mkdirp yes :tangle ./ex1/project.clj :exports none
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure  "1.5.1"]
                ]
  :repl-options {:init-ns ex1.core})
#+END_SRC
#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/doc/intro.md :exports none
# Reversible Arithmetic on Collections
TODO: The project documentation is the .org file that produced
this output, but it still pays to read
http://jacobian.org/writing/great-documentation/what-to-write/
#+END_SRC
#+name: top-level-load-block
#+BEGIN_SRC clojure :exports none :mkdirp yes :tangle ./ex1/src/ex1/core.clj :padline no :results silent :noweb yes
<<main-namespace>>
<<reversible-algebraic-vector-protocol>>
<<check-a-vector>>
<<get-a-vector-helper>>
<<one-type>>
<<add-data>>
<<sub-data>>
<<inner-product-data>>
<<undo>>
<<redo>>
<<reversible-algebraic-vector-on-vector>>
#+END_SRC

#+name: main-namespace
#+BEGIN_SRC clojure :results silent :exports none
(ns ex1.core)
#+END_SRC

* Unit-Tests

#+BEGIN_SRC clojure :exports none :mkdirp yes :tangle ./ex1/test/ex1/core_test.clj :padline no :results silent :noweb yes
<<test-namespace>>
<<bad-ish-test-set>>
<<get-a-vector-helper-test>>
<<one-type-test>>
#+END_SRC

#+name: test-namespace
#+BEGIN_SRC clojure :results silent
(ns ex1.core-test
  (:require [clojure.test :refer :all]
            [ex1.core     :refer :all]))
#+END_SRC

* REPLing
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
1. Set up emacs and nRepl (TODO: explain; automate)
2. Edit your init.el file as follows (TODO: details)
3. Start nRepl while visiting the actual |project-clj| file.
4. Run code in the org-mode buffer with \verb|C-c C-c|; results of
   evaluation are placed right in the buffer for inspection; they are
   not copied out to the PDF file.
